;;; TeleoReactive Turtles 
;;; Version 0.1, 2016 Ilias Sakellariou
;;; 

;;;;;;;;;;;;;;; Test Code
extensions [table]

to test
   add-percept "holding"
   add-percept "see-depot"
   show "Rules"
   foreach item 1 tr#rules [show ? show tr#evaluate-cond ?]
   show "Mathcing"
   show tr#matching-rule-actions
end 


;;; 

;;; This is complicated 
;;; If it is a timed sequence, then each action is executed in turn for that time. 
;;; If it is a Sequence of durative and discrete actions, then these are all executed in one circle (?)
to execute-rules
   update-percepts
   if tr#perc-change ;; if environment changes, then we have to re-evaluate.
     [;d; let tr#currect-set first tr#matching-rule-actions ;; Get the first rule that matches.
      ;d; let tr#currect-set tr#matching-first-rule-actions ;; works simpler.
      ;d; Add the new actions to the execution structure.
      ;d; tr#add-actions tr#currect-set
      
      ;;; find the first rule that matches
      let lv#tr#next-rule-to-add  tr#matching-first-rule
      let lv#tr#next-ruleid (tr#rule-id lv#tr#next-rule-to-add)
      
      ;;; So if it is the same rule change nothing.
      if (lv#tr#next-ruleid != tr#current-rule-id)
          [ tr#add-actions tr#rule-action lv#tr#next-rule-to-add
            table:put teleor-store "tr#current-rule-id" lv#tr#next-ruleid
          ]  
      ]
       ;; [foreach  tr#last-actions [run ?]] ;; run previous actions  
   tr#run-next-action
   ;;; clean up the percept flag
   tr#cleanup-step
end




;;; Main Data Structure
to tr-init
  set teleor-store table:make
  table:put teleor-store "tr#percepts" table:make
;;  table:put teleor-store "tr#percepts-temp" []
  table:put teleor-store "tr#durative-actions" []
  table:put teleor-store "tr#discrete-actions" [] 
  table:put teleor-store "tr#rules" []
  table:put teleor-store "tr#change" true ;; Initially needs true to work.
  table:put teleor-store "tr#current-action-sequence" []
  tr#reset-action-counter ;; this is = table:put teleor-store "tr#counter" 1
  table:put teleor-store "tr#current-action" 0
  table:put teleor-store "tr#current-pp-action" []
  table:put teleor-store "tr#current-rule-id" 0 
  table:put teleor-store "tr#length" 0
  table:put teleor-store "tr#procedures" []
  
  
  show "Inited"
end

;;; Counter Operations

to tr#cleanup-step
   ;; clearing percept update flag
   table:put teleor-store "tr#change" false
end

to tr#run-next-action
  ;; Debug
  show (word "Actions:" tr#current-action-sequence " Counter:" tr#action-counter " Percept Change:" tr#perc-change)
  show (word "Next Action Structure:" tr#next-action-str)
  show (word "Next Action to run:" tr#next-action)
  show (word "Next Action Update:" tr#updated-action) 
  show (word "++Actions:" tr#current-pp-action) 
  ;;; run the action(s)
  tr#run-action 
  
  ;Remove ;; If it is not a number it is either a durative action with inf or a discrete action - no check.
  ;Remove ;; is-number? tr#next-action-counter and tr#action-counter >= tr#next-action-counter) ;; Safety in >=
  
  ifelse ( tr#remove-action? )
     [ ;;;  places action from a list to the end.
       table:put teleor-store "tr#current-action-sequence" (lput (tr#updated-action) (but-first tr#current-action-sequence))
       tr#reset-action-counter ;; resets counter for the next action in sequence
     ]
     [tr#inc-action-counter]  ;; else increase the counter. 
end

;;; Reporter stating the conditions that should hold for the counters.
;;; Conditions to remove an action
to-report tr#remove-action?
  if tr#next-action-counter = "inf" [report false]
  if tr#next-action-counter = "seq" [report false]
  ;; remove and reset counter in dis actions. Attention returns true!
  if tr#next-action-counter = "dis" [report true]
  ;; check end condition
  report (tr#action-counter >= tr#next-action-counter)
end

;;; Handle changes to an action
;; Used for repeat (and possibly other in the future)
to-report tr#updated-action 
    report ifelse-value (first tr#next-action-str = "tr#repeat")
         [replace-item 1 tr#next-action-str (item 1 tr#next-action-str - 1) ]     
         [tr#next-action-str]
end


;;if member? "tr#repeat" first (list (word "tr#repeat " 5) "dis") 


;;; Runs a single action or an action sequence.
;;; If it is an action sequence (list), then we could 
;;; have the updated action filtered once (opt) 
to tr#run-action 
    ifelse is-list? tr#next-action
      [foreach (ifelse-value (tr#action-counter = 1) 
                 [tr#next-action] 
                 [filter [tr#durative-action? ?] tr#next-action ] )
                     [run ?] ]
      [run tr#next-action]
    
    ;; Run ++ actions 
    foreach tr#current-pp-action [run ?]
      
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; REPORTERS FOR TELEO STRUCTURE
to-report tr#percept-list
  report table:get teleor-store "tr#percepts"
end

to-report tr#durative-actions
  report table:get teleor-store "tr#durative-actions"
end

to-report tr#discrete-actions
  report table:get teleor-store "tr#discrete-actions"
end

;;; Reports the set of TR Rules
to-report tr#rules
  report table:get teleor-store "tr#rules"
end

;;; Reports the set of rules i
to-report tr#rules-list 
  report item 1 tr#rules
end

to-report tr#perc-change
  report table:get teleor-store "tr#change" 
end

to-report tr#last-actions
  report table:get teleor-store "tr#lastDurativeActions" 
end

to-report tr#current-action-sequence
  report table:get teleor-store "tr#current-action-sequence"
end

to-report tr#current-rule-id
  report table:get teleor-store "tr#current-rule-id"
end 

to-report tr#next-action-str
  report first tr#current-action-sequence
end

;;;  Next Action to execute
to-report tr#next-action
  report first tr#next-action-str
end

;;; Next Action Counter
to-report tr#next-action-counter
  report item 1 tr#next-action-str
end

to-report tr#current-pp-action
   report table:get teleor-store "tr#current-pp-action"
end

to tr#add-duative-actions [tr#currect-set]
  table:put teleor-store "tr#lastDurativeActions" filter [member? ? tr#durative-actions] tr#currect-set
end

;;; Add the actions of the rule in the current action sequence and make approrpiate 
;;; initialisation operations.
;;; tr#current-action is the first action (index in the sequence)
;;; action counter is reset
to tr#add-actions [tr#action-list]
  table:put teleor-store "tr#current-pp-action" tr#action-list-seq tr#action-list
  table:put teleor-store "tr#current-action-sequence" filter [first ? != "++"] tr#action-list
  table:put teleor-store "tr#length" length tr#action-list
  table:put teleor-store "tr#current-action" 0
  tr#reset-action-counter
end

to-report tr#action-list-seq [tr#action-list]
  let tr#local-list filter [first ? = "++"] tr#action-list
  report ifelse-value (empty? tr#local-list) [ [] ] [but-first first tr#local-list]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Action counter operations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; reset action counter
to tr#reset-action-counter
  table:put teleor-store "tr#counter" 1
end

;; report the action counter
to-report tr#action-counter
  report table:get teleor-store "tr#counter"
end

;;; increase action counter
to tr#inc-action-counter
  table:put teleor-store "tr#counter" (tr#action-counter + 1) 
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Gets a list of actions and time declarations and provides a list of 
;;; lists, each item holds an action and a duration.
to-report tr#build-action-sequence [tr#action_list]
  if empty? tr#action_list [report []]
  ;; This one is always an action
  let tr#action first tr#action_list
  ifelse length tr#action_list > 1 and 
         tr#is-action-or-seq? tr#action and 
         tr#for-declaration? (item 1 tr#action_list) 
     [report (fput (list tr#action tr#for-duration (item 1 tr#action_list) ) tr#build-action-sequence (but-first but-first tr#action_list))]
     [report fput (tr#fix-action-struct tr#action) tr#build-action-sequence but-first tr#action_list]           
end

;;; If an action is durative the add inf as a duration
;;; If an action is discrete then add dis as a marker.
to-report tr#fix-action-struct [tr#action]
  ;; Support for the empty action
  if (tr#action = []) [report (list "no-action" "inf")]
  if (first tr#action = "++") [report tr#action]
  if (is-list? tr#action) [report (list tr#action "seq")]  
  report (list tr#action ifelse-value tr#durative-action? tr#action ["inf"] ["dis"])  
end

;;; This is not needed now, but possibly later
;;; A check is done.
to-report tr#is-action-or-seq? [tr#action]
  if is-list? tr#action  
     [report reduce [? and ?] map [ tr#valid-action? ? ] tr#action]
  report tr#valid-action? tr#action
;     ] 
;  ifelse (tr#durative-action? tr#action or tr#discrete-action? tr#action or build-in-action? tr#action)
;     [report true]
;     [error (word "Action * " tr#action " * is not declared as durative or dicrete.")]
end



to-report tr#for-declaration? [tr#for-decl]
  report is-list? tr#for-decl and first tr#for-decl = "for"
end

to-report tr#for-duration [tr#for-decl]
  report item 1 tr#for-decl
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; LANGUAGE CONSTRUCTORS 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to-report # [tr#Cond tr#Action tr#RestRules]
  report fput (fput task [tr#percept-check tr#Cond] tr#Action) tr#RestRules
end

;;; Conjunction "Operator" 
to-report & [tr#percept tr#Rest]
   report (fput task [tr#percept-check tr#percept] tr#Rest)
end 

;;; The -> operator builds the list of actions. A single action means 
;;; is is turned to a list and a list of actions become lists.
to-report -> [tr#action tr#rest-actions]
    report (list tr#build-action-sequence fput tr#action tr#rest-actions)
end

;;;  For construct (durative actions)
to-report for [tr#N tr#rest-actions]
  report fput (list "for" tr#n) tr#rest-actions
end 

;; End of rule reporter
to-report .
  report []
end

;;; Rule separator
to-report : [tr#action tr#rest-actions]
  report (fput tr#action tr#rest-actions)
end

;;;; TR Action Modifiers 

to-report ++ [tr#action tr#rest-actions]
  report fput (list "++" tr#action) tr#rest-actions
end 

;; This is a trick. If there is a wait, then the previous sequence must be executed once. 
;; This is acheived by placing for 1 in front of the list. 
to-report wait-repeat [tr#wait-v tr#repeat-v tr#rest-actions]
  report for 1 fput "tr#wait" for tr#wait-v fput (word "tr#repeat " tr#repeat-v) tr#rest-actions
end

to procedure [tr#name tr#RuleList]
   ;table:put teleor-store "tr#rules" (list tr#name tr#RuleList)
   table:put teleor-store "tr#rules" (list tr#name (tr#add-id-to-rules tr#name 1 tr#RuleList))
   table:put teleor-store "tr#procedures" (fput tr#name table:get teleor-store "tr#procedures")
   ;show tr#add-id-to-rules tr#name 1 tr#RuleList
end

to-report end-procedure
  report []
end

to durative-actions [tr#list]
  table:put teleor-store "tr#durative-actions" tr#list
end

to discrete-actions [tr#list]
  table:put teleor-store "tr#discrete-actions" tr#list
end

;;; Recursively assigns an ID to each rule.
to-report tr#add-id-to-rules [tr#name tr#num tr#RuleList]
     if empty? tr#RuleList [report []]
     report (fput (lput (word tr#name "-" tr#num) (first tr#RuleList) )
              (tr#add-id-to-rules tr#name (tr#num + 1) (but-first tr#RuleList)))
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Perception Handling
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Initialising a table with an entry for each percept.
to percepts [tr#list]
  foreach tr#list [table:put tr#percept-list ? false]
  table:put tr#percept-list "true" true ;; dummy condition always true
end

;;; Reports the value of a percept. 
;;; Since these are truw false, reports true false.
to-report tr#percept-check [tr#perc]
  tr#check-percept-exists tr#perc
  report table:get tr#percept-list tr#perc
end

;;; Adding a boolean Percept.
to add-percept [tr#perc]
   tr#check-percept-exists tr#perc
   if not tr#percept-check tr#perc 
     [tr#percept-update tr#perc true]
end

to no-percept [tr#perc]
 tr#check-percept-exists tr#perc
 if tr#percept-check tr#perc
     [tr#percept-update  tr#perc false]     
end

;;; Updates percept to a new value
to tr#percept-update [tr#perc tr#perc-value]
  table:put tr#percept-list tr#perc tr#perc-value
  table:put teleor-store "tr#change" true
  show "update"
end

;;; Cheking wheather a percept exists.
to tr#check-percept-exists [tr#perc]
  if not table:has-key? tr#percept-list tr#perc [error (word "No percept " tr#perc " declared.")] 
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Rules  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Rules are lists that have reporter tasks (i.e. conditions) and annotated actions
;;; and an id (string)
;;; i.e. lists themselves. 
to-report tr#evaluate-cond [tr#rule]
  report reduce [?1 and ?2] map [run-result ?] filter [is-reporter-task? ?] tr#rule    
end

to-report tr#rule-action [tr#rule]
   report first filter [is-list? ?] tr#rule
end

;;; Report the id (i.e. string) of the action
to-report tr#rule-id [tr#rule]
   report first filter [is-string? ?] tr#rule
end

;;; This is an overkill. Just get the first rule. This way we will push the names of the procedures are well.
;;; Obsolete:: Delete next iteration
to-report tr#matching-rule-actions 
  report map [tr#rule-action ?] filter [tr#evaluate-cond ? ]  tr#rules-list
end


to-report tr#matching-first-rule-actions
  foreach tr#rules-list [if (tr#evaluate-cond ?) [report tr#rule-action ?]]
end

;;; Reports the first matching rule (complete with conditions and ID)
to-report tr#matching-first-rule
  foreach tr#rules-list [if (tr#evaluate-cond ?) [report ?]]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Special Build-in Actions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Nothing to do.
to no-action
  
end
;;; Wait does nothing.
to tr#wait  
  ;; do nothing 
end



;;; An action that changes the internal state. CAREFULL
to tr#repeat [N]
  if N = 0 [user-message (word "Action " but-first tr#current-action-sequence  " Failed due to repeat.")] ;; do nothing
  table:put teleor-store "tr#current-action-sequence" 
     (fput (list (word "tr#repeat " (N - 1)) "dis") 
         (but-first tr#current-action-sequence))
end

;;; Is it a valid action? 
to-report tr#valid-action? [tr#action]
   ifelse tr#discrete-action? tr#action 
        or tr#durative-action? tr#action
        or build-in-action? tr#action
     [report true]   
     [error (word "Action * " tr#action " * is not declared as durative or dicrete.")]    
end


;;; Reports true if the argument is a discrete action
to-report tr#discrete-action? [tr#action]
  report member? tr#action tr#discrete-actions
end


;;; Reports true if the argument is a durative action
to-report tr#durative-action? [tr#action]
  report member? tr#action tr#durative-actions
end

;;; Used for checks
to-report  build-in-action? [tr#action]
  report member? tr#action ["no-action" "tr#wait" "tr#repeat" [] ]
         or member? "tr#repeat" tr#action
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Debugging
to dbg-tr#percepts-print
  foreach table:to-list tr#percept-list
     [show ?]
end




