;;; TeleoReactive Turtles 
;;; Version 0.1, 2016 Ilias Sakellariou
;;; Note: This is a modified version of the TSTATES Library, that directly supports X-Machine Execution. The trick comes from 
;;; modifying the transition from "condition" - "action" to a x-func transition that has a commitment part, generated automatically by the function 
;;; if the latter succeeds. This part is actually the output and the memory values that form the "output" of the function triggered. 
;;; Thus, with little modifications the TSTATES library hosts now X-machines. 

;;; Should point out that the TSTATES lib actually invokes special form of functions. 
;;;  list of variables required for each turtle.
;;;  active-states ;; The current state of the world
;;;  active-states-code ;; The code defined for the specific state.
;;;  active-machines ;; List of reporters indicating which machine is active 
;;;  active-machine-names ;; list of active machine names

;;; Changes 
;; a) Functions do not need the Percept Memory Emotion parameters. These are predetermined. 
;; b) Memory is now a table (better handling)
;; c) Output is now an action. 



extensions [table]


;;; Simple X-machines (With emotions)

;;; state definition

;;; Loads the code of the state in memory
;;; Carefull sname#sm here is a string representing the state name.
;;; BUT the active state is a list (name mod). 
to load-state#sm [sname#sm]
    ;; loads only if we are at a different state
    if current-state-name#sm != sname#sm 
    [let states-matched#sm filter [state-name#sm ? = sname#sm] state-definition-of#sm  ;;  This loads all the code.   
     if empty? states-matched#sm [user-message (word "Tutrle " who ":Error possibly incorrect state nane: " sname#sm ". Previous-state:: " current-state-name#sm) stop]
     set active-states-code fput state-code#sm first states-matched#sm but-first active-states-code;; select the first of the matched code.
     set active-states fput state-name-and-mode#sm first states-matched#sm but-first active-states  ;; remove the topmofthe stack and then put the new one.
     ] 
end 


to activate-machine#sm [machine-name#sm]
    ;; The new machine is on top
    set active-machines fput taskify#sm (word "state-def-of-" machine-name#sm) active-machines 
    set active-machine-names fput machine-name#sm active-machine-names
    ;; get the initial state in place
    push-state#sm init-state#sm
end

;;; push is deffent to load since the previous state is not removed.    
to push-state#sm [sname#sm]
     let states-matched#sm filter [state-name#sm ? = sname#sm] state-definition-of#sm  ;;  This loads all the code.  
     if empty? states-matched#sm [user-message (word "Error possibly incorrect state nane: " sname#sm ".") stop]
     set active-states-code fput state-code#sm first states-matched#sm active-states-code;; select the first of the matched code and add it.
     set active-states fput state-name-and-mode#sm first states-matched#sm active-states  ;; put the new state machine to the stack 
end

;; success 1 / fail 0 
;; unloading means that the machine is now off. So forget about it.
to deactivate-machine#sm [mode#sm]
    
    set active-states but-first active-states ; removing the current active state
    set active-states-code but-first active-states-code ; removing the current active state code

    let returning-machine first active-machine-names   ; keep the name 
    set active-machine-names but-first active-machine-names ;; kill the machine name  
    set active-machines but-first active-machines ; disabling the machine
    ;; so now the calling state is on top
    ;; assert-result#sm mode#sm current-state-name#sm
    ;; we are pushing here the semantic limits of the language.
    
    ; Functional can be sometimes nice!
    set active-states fput (list current-state-name#sm 
     ifelse-value (mode#sm)
       [fput returning-machine remove returning-machine current-state-mode-true#sm]
       [remove returning-machine current-state-mode-true#sm]
     ifelse-value (mode#sm)
       [remove returning-machine current-state-mode-false#sm]  
       [fput returning-machine remove returning-machine current-state-mode-false#sm]
       )
        but-first active-states

end


;;; Reports the current state of the agent.
to-report current-state#sm
  report first active-states
end 

to-report current-state-name#sm
  report first current-state#sm
end

to-report current-state-mode-true#sm
  report item 1 current-state#sm
end

to-report current-state-mode-false#sm
  report item 2 current-state#sm
end

to-report current-state-code#sm
  report first active-states-code
end
;;;;;;;;;;;;;;;;;;;;;

;;; utilities to check previous states
to-report state-stack#sm
 report map first active-states 
end
;;; Reports true if the state that invoked the current state is 
;;; that of the parameter
to-report invoked-from [ state#sm ]
  let sts state-stack#sm
  report (length sts > 1 and item 1 sts = state#sm) 
end

;;; Reports true if the state of the parameter is active (in stack)
to-report previous-active-state [ state#sm ]
  report member? state#sm state-stack#sm
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; init active-states as a list
;;; get the first as the active state
;;; Load it.
to initialise-state-machine
  ;; Coudl be removed in a late implementation
  ;set outs []
  ;; dummy states and dummy code was entered so that we have a uniform (and fast) load-state code.
  set active-states [["dumy-initial-state#sm" [] [] ]]
  set active-states-code ["dumy-code#sm"]
  set active-machines (list taskify#sm (word "state-def-of-" breed)) ;; init the primary machine
  set active-machine-names (list breed) ;; set the name of the active machine
  load-state#sm init-state#sm
end


;;; Main code for executing the state machine
to execute-state-machine
  ;set outs []
  let trans#sm filter [runresult first ?] current-state-code#sm ;; so only valid transitions are in list!
  if check? [
         set max-trans ifelse-value (max-trans > length trans#sm) [max-trans] [length trans#sm]
         if length trans#sm > 1 [output-show (word current-state-name#sm" " length trans#sm )  ]
         ]
  ifelse not empty? trans#sm 
     [let current-transition first trans#sm   ; we pick up the first transition
      run trans-action#sm current-transition  ; action
      run trans-target#sm current-transition] ; change of state to target state
   [show (word "No state transition applicable from " current-state-name#sm)
    if check? [output-show percept output-show memory]  
     ] 
end 

;;; does not work as yet
to check-code [br]
  ca 
  reset-ticks
  ;; Since the code must run in turtle context with all breed specific vars created
  ;; we create a "dummy" turtle of tyhe specific breed and check the code.
  run (word "create-" br " 1 ")
  ask turtle 0 [   
      show (word "Checking states for breed" br)   
      ;; load the code in a var
      let code#sm runresult (word "state-def-of-" br)
      let all-states#sm []
      ;; collects state definitions
      foreach code#sm [set all-states#sm lput state-name#sm ? all-states#sm] 
      ;; should add a case for dublicates
      ;; check if transitions lead to a valid state 
      foreach code#sm [check-a-state#sm ? all-states#sm]
      ;; Show the staes processed.
      show (word "States checked:: " all-states#sm) 
      die ;; the "dummy" says good bye.
      ]
end 

;;; no need to specify anything else. 
;;; takes the reporter created during machine init by other  
to-report state-definition-of#sm
     report runresult first active-machines
end 

;;; Check one state for invalid transitions
;;; Internal as the name indicates <>#sm
to check-a-state#sm [state-descr#sm all-states#sm]
  let sname#sm state-name#sm state-descr#sm
  foreach (but-first state-descr#sm) 
     [if (not member? (last ?) all-states#sm) 
      [show (word "From state::" sname#sm " transition to undefined state " (last ?))] ] 
end

;;; ((state-name true-list false-list) (cond action target_state) (cond action target_state))

;;; So the idea is to first make everything a list of strings and then 
;;; compile the code.

;;; State Data structure operations
to-report init-state#sm
  report  state-name#sm first runresult first active-machines
end 


;;; A transition is of the form (cond action target_state)
;;; transition manipulation reporters
to-report trans-condition#sm [trans#sm]
  report first trans#sm
end

;;; transition action
to-report trans-action#sm [trans#sm]
  report item 1 trans#sm
end 

;;; transistion target state
to-report trans-target#sm [trans#sm]
  report item 2 trans#sm
end

;;; state-manipulation reporters
to-report state-name#sm [state#sm]
  report first first state#sm
end

;;; A state has the form
;;; ((state-name true-list false-list) (cond action target_state) (cond action target_state))

;;; truelist
to-report state-mode-true#sm [state#sm]
  report item 1 state-name-and-mode#sm state#sm
end

;;; falselist
to-report state-mode-false#sm [state#sm]
  report item 2 state-name-and-mode#sm state#sm
end

;; report the name and mode information of the state
to-report state-name-and-mode#sm [state#sm]
  report first state#sm
end

;;; reports the code of the state  
to-report state-code#sm [state#sm]
  report but-first state#sm
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; State operators 
;;; Nice. Check out the lists that are true false.
to-report state [sname#sm incomplete-state#sm]
  report (fput (list sname#sm  [] [] )incomplete-state#sm)
end 

to-report end-state
  report []
end

;;; Condition Part of transition description
to-report when [action-condition#sm incomplete-state#sm]
  report fput taskify#sm action-condition#sm incomplete-state#sm
end 

to-report otherwise [incomplete-state#sm]
  ;;report fput taskify#sm "true" incomplete-state#sm
  report fput task [true] incomplete-state#sm
end   
  
to-report on-success [machine#sm incomplete-state#sm]
 ; report fput taskify#sm (word "ifelse-value (member? \"" machine#sm "\" current-state-mode-true#sm) [true][false]") incomplete-state#sm
 report fput task [ifelse-value (member? machine#sm current-state-mode-true#sm) [true][false]] incomplete-state#sm
end 

to-report on-failure [machine#sm incomplete-state#sm]
  ;report fput taskify#sm (word "ifelse-value (member? \"" machine#sm "\" current-state-mode-false#sm) [true][false]") incomplete-state#sm
  report fput task[ ifelse-value (member? machine#sm current-state-mode-false#sm) [true][false]] incomplete-state#sm
end   

to-report for-n-ticks [n incomplete-state]
  let t ticks + n
  ;;show (word "ticks:here:" t)
  report fput (task [ticks  < t]) incomplete-state
end   

to-report after-n-ticks [n incomplete-state]
  let t ticks + n
  ;;show (word "ticks:here:" t)
  report fput (task [ticks  > t]) incomplete-state
end   

;;; Action Part of transition description
  
to-report do [action#sm incomplete-state#sm]
  report fput taskify#sm action#sm incomplete-state#sm
end 

to nothing
end

to no-action
end

;;; Transition part indicating target states 
to-report goto [sname#sm]
  ;report (list taskify#sm (word "load-state#sm " "\"" sname#sm "\"")) 
  report (list task [load-state#sm sname#sm])
end

;; needs a bit of feeling up.
to-report activate-machine [sname#sm]
  ;report (list taskify#sm (word "activate-machine#sm " "\"" sname#sm "\"")) 
  report (list task [activate-machine#sm sname#sm] )
end

;; Sucess state - deactivates the machine and changes the status to 1
to-report success 
  ;;report (list taskify#sm (word "deactivate-machine#sm true")) 
  report (list task [deactivate-machine#sm true]) 
end

;; Fialure state - deactivates the machine and sets status to 0
to-report failure
  ;report (list taskify#sm (word "deactivate-machine#sm false"))
  report (list task [deactivate-machine#sm false])
end

;;; Taskify Utility. 
to-report taskify#sm [what#sm]
  report runresult (word "task [" what#sm " ]")
end
  
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Xmachine Formalism Related Procedures
to-report x-func [xfunction#sm incomplete-state#sm]
  ;report fput taskify#sm (word "xfunc#xsm " "\"" xfunction#sm "\"") (fput (word "func-commit#xsm " "\"" xfunction#sm "\"") incomplete-state#sm) 
  report fput task [xfunc#xsm xfunction#sm] (fput task[func-commit#xsm xfunction#sm] incomplete-state#sm) 
end 

;;; this is the executable 

to-report xfunc#xsm [x-function]
 report first runresult x-function   
; let res runresult x-function 
; if (first res) 
;    [let out#xsm item 1 res
;     let mem#xsm item 2 res
;     if (trace? and trace-turtle = who) [output-show (word ticks ":" (list x-function out#xsm mem#xsm)) ] ;; Debugging. 
;     set outs (fput (list x-function out#xsm mem#xsm) outs )
;     ]
; ;;; this reports true or false that is used to filter states.    
; report first res
end 


;;; template [ <function-name> <output> <memory updates>]
;;; Example:: template ["perceiveDanger" [task [fd 1] task [rt 2]] [["speed" 32] ["stamina" 19]]]
;;; [functionName Output Memory]
to func-commit#xsm [x-function]
  let res runresult x-function
  update-x-memory#sxm item 2 res
  run-x-actions#sxm item 1 res

;  foreach outs 
;    [if (first ? = x-function) 
;       [update-x-memory#sxm item 2 ?
;        run-x-actions#sxm item 1 ?
;       ]
;    ]      
end

;;; Executing Actions upon function commit. Since actions are
;;; in a list, its means that the we execute each function in order. 
to run-x-actions#sxm [sxm#Actions]
  foreach sxm#Actions
    [run ?]  
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Memory Functions 
;;; Updates the memory Using a list (internal)
to update-x-memory#sxm [MemoryChanges#xsm]
  foreach MemoryChanges#xsm
   [ ifelse (table:has-key? memory (item 0 ?) )
       [table:put memory (item 0 ?) (item 1 ?)]
       [show (word "Error! There is no such memory value " (item 0 ?) ) ]
   ]
end

;;; Memory is now a table. 
;;; init-x-memory [<memorVars >]
to init-x-memory ; [VarsValues#xsm]
   set memory table:make
end

;;; Declaring initial memory elements and values.
to x-mem-initial-var [Var#xsm Value#xsm]
  table:put memory Var#xsm Value#xsm
end

;;; Setting a value. Used inside transition definitions
to-report x-mem-set [MemVar#xsm Value#xsm Updates#xsm]
  report fput (list MemVar#xsm Value#xsm) Updates#xsm
end

;;; Get the value of a memory value
to-report x-mem-value [MemVar#xsm]
  report table:get memory MemVar#xsm
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Action Definition
;;; An action definition is a list of NetLogo tasks that 
;;; are going to be executed when the transition is selected.

;;; Adds a new action to the list of actions. 
to-report x-action [Action#xsm RestActions#xsm]
  report fput Action#xsm RestActions#xsm
end

;;;  True part of xfunction
to-report x-true [Actions#xsm MemUpdates#xsm]
  report (list true Actions#xsm MemUpdates#xsm)
end 

;;; The false part of the xfunction
to-report  x-false 
  report [false]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Percepts
;;; Percepts are in a list, so that we can have dublicate percepts (so we could not use 
;;; arrays or tables).
;; Checking that a percept exists
;;; x-percept-add Name Value

;;; Clearing Percepts
to x-clear-percepts
  set percept []
end

;;; Adding a percept-value pair.
to x-add-percept-value [perc-name#xsm perc-value#xsm]
   set percept fput (list perc-name#xsm perc-value#xsm) percept
end

;;; Adding a percept (dummy value "x-nil")
to x-add-percept [perc-name#xsm]
  x-add-percept-value perc-name#xsm "x-nil"
  ;set percept fput (list perc-name#xsm "x-nil") percept
end

;;; Checks if there is a percept-value pair in the percepts
to-report x-has-percept? [perc-name#xsm]
  report  not empty? filter [first ? = perc-name#xsm] percept
end

;;; Reports the first percept-value
to-report x-percept-value [perc-name#xsm]
  report  item 1 first filter [first ? = perc-name#xsm] percept
end

;;; Reports one of values in percept-value pairs
to-report x-oneof-percept-value [perc-name#xsm]
  report  item 1 one-of filter [first ? = perc-name#xsm] percept
end
 
;;; Reports all values for the specific percept as a list 
to-report x-all-percept-values [perc-name#xsm]
  report  map [item 1 ?] (filter [first ? = perc-name#xsm] percept)
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Syntax Related Functions.

;;; Dummy Just Syntactic Sugar
;;; Start of memory updates
to-report #< [Arg]
  report Arg
end

;;; end of memotry updates
to-report >#
  report []
end 


